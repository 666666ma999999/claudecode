{
  "id": "1",
  "subject": "BE: execute_batch abort logic + run_batch_check dict return",
  "description": "Modify check_playwright.py and check.py to implement batch abort on failure.\n\n**File 1: check_playwright.py**\n\n1a. `execute_batch` (line 1932): Change signature to `async def execute_batch(self, item_ids: list, abort_threshold: int = 2) -> dict:`\n\n1b. In normal_items loop (line 1982 after `results.append(result)`), add abort check:\n```python\n# Abort check\nif result.confidence <= abort_threshold or result.error:\n    abort_info = {\n        \"reason\": f\"confidence={result.confidence}\" + (f\", error={result.error}\" if result.error else \"\"),\n        \"item_id\": item_id,\n    }\n    break\n```\nInitialize `abort_info = None` before loop. Same for exception handler (line 1985-1990) - set abort_info and break.\n\n1c. In analytics_items loop (line 1996-2008), same abort logic - after append, check confidence/error.\n\n1d. After all loops, build remaining IDs:\n```python\nprocessed_ids = [r.item_id for r in results]\nremaining_ids = [i for i in item_ids if i not in processed_ids]\n```\n\n1e. Return dict instead of list:\n```python\nreturn {\n    \"results\": results,\n    \"aborted\": abort_info is not None,\n    \"abortReason\": abort_info[\"reason\"] if abort_info else None,\n    \"abortItemId\": abort_info[\"item_id\"] if abort_info else None,\n    \"processedItemIds\": processed_ids,\n    \"remainingItemIds\": remaining_ids,\n}\n```\n\n2a. `run_batch_check` (line 2074): Add `abort_threshold: int = 2` parameter. Pass to `executor.execute_batch(item_ids, abort_threshold)`.\n\n2b. Change `run_batch_check` return type from `list` to `dict`. The result from execute_batch is now a dict. Access results via `batch_result[\"results\"]` (was `check_results`). Update log section to use `batch_result[\"results\"]`.\n\n2c. Add abort logging:\n```python\nif batch_result[\"aborted\"]:\n    logger.info(f\"[BATCH_ABORT] ppv={ppv_id} aborted_at={batch_result['abortItemId']} reason={batch_result['abortReason']} remaining={len(batch_result['remainingItemIds'])}\")\n```\n\n2d. Build and return full dict:\n```python\nreturn {\n    \"results\": formatted,\n    \"aborted\": batch_result[\"aborted\"],\n    \"abortReason\": batch_result.get(\"abortReason\"),\n    \"abortItemId\": batch_result.get(\"abortItemId\"),\n    \"processedItemIds\": batch_result.get(\"processedItemIds\", []),\n    \"remainingItemIds\": batch_result.get(\"remainingItemIds\", []),\n}\n```\n\n**File 2: check.py**\n\n3a. BatchCheckRequest (line 84-89): Add `abortThreshold: Optional[int] = 2`\n\n3b. batch_check endpoint (line 234-264): Pass `abort_threshold=request.abortThreshold` to `run_batch_check`. Change return from `{\"results\": results}` to `return result` (the dict from run_batch_check directly).\n\nIMPORTANT: Use absolute paths:\n- /Users/masaaki/Desktop/prm/chk/check_playwright.py\n- /Users/masaaki/Desktop/prm/chk/check.py",
  "activeForm": "Implementing BE abort logic",
  "status": "pending",
  "blocks": [],
  "blockedBy": []
}