# 実行ガード

## 1. ブロッカープロトコル

タスク実行中に以下が発生した場合、**即座に停止してユーザーに確認**:

| ブロッカー | 対応 |
|-----------|------|
| プランの指示が不明確 | 停止 → 具体的な質問を提示 → 回答を待つ |
| テスト/検証が失敗 | 停止 → 4段階根本原因分析に従い調査 → 報告 |
| プラン外の変更が必要と判明 | 停止 → 追加変更の範囲を提示 → 承認を待つ |
| 想定外の依存関係を発見 | 停止 → 影響範囲を報告 → 判断を待つ |

**禁止**: ブロッカーを推測で回避、「おそらくこうだろう」で判断して修正

## 2. バッチ実行方式

タスクを3つずつバッチ化し、バッチごとに検証ポイントを設ける:
- バッチ実行 → 検証 → ユーザーへ中間報告 → 承認後に次バッチ
- 単純な変更: 最大5タスク/バッチまで拡大可
- リスクの高い変更: 1タスク/バッチに縮小

## 3. SubAgent委託テンプレート

SubAgentにタスク委託時、以下を全て提供すること:
```
1. Goal: このタスクで達成すべきこと
2. Context: 関連ファイルパス・関数名・データフロー
3. Spec: 入出力の仕様（型・値の範囲・エッジケース）
4. Constraints: 既存コードとの整合性要件
5. Verification: テストコマンドと期待結果
```
**必要な情報が全て委託内容に含まれている**状態が理想。

### 3.1 コンテキスト予算チェック（データ分析SubAgent向け）

SubAgentにデータ抽出・分析を委託する前に、以下の基準で予算超過リスクを判定する:

| 危険信号 | 閾値 | 対応 |
|---------|------|------|
| SQLクエリ結果の合計行数 | >100行 | Extract-to-File方式に切替 |
| レポート出力の想定行数 | >150行 | セクション分割して複数SubAgent |
| 1SubAgentあたりのSQLクエリ回数 | >10回 | フェーズ分割 |
| データ期間 × セグメント数 × 指標数 | >500セル | Extract-to-File方式必須 |

**Extract-to-File方式（強制パターン）**:

```
Phase 1: データ抽出SubAgent
  - SQLクエリ → Python → CSV/TSVファイルに出力
  - 出力先: project/boradmtg/tmp/{テーマ}_{YYYYMMDD}.csv
  - SubAgentのコンテキストにクエリ結果を保持しない

Phase 2: 分析・レポートSubAgent
  - Phase 1の出力ファイルを入力として読み込み
  - 分析 → Markdownレポート出力
  - 必要に応じてセクション別に複数SubAgentに分割
```

**中間ファイルルール**:

| 項目 | 基準 |
|------|------|
| 配置先 | `project/boradmtg/tmp/` |
| 命名 | `{テーマ}_{YYYYMMDD}.csv` |
| ライフサイクル | レポート完成後に手動削除（.gitignoreで追跡対象外） |
| フォーマット | CSV（ヘッダー付き、UTF-8） |

**禁止事項**:
- 100行超のSQLクエリ結果をSubAgentのコンテキストに保持すること
- データ抽出 + 分析 + レポート生成を1つのSubAgentに詰め込むこと
- 中間ファイルなしで大量データを次フェーズに渡すこと

## 4. デバッグ鉄則

**根本原因を特定するまで修正に着手しない。** 3回修正失敗で停止。詳細は debugging-guide スキル参照。

## 5. リファクタリング戦略

参考コード方式で横展開。詳細は refactoring-guide スキル参照。

## 6. プラン作成基準

Plan SubAgentが作成するプランには以下を含める:
- Goal（1-2文）、Architecture（モジュール構成図）、Tech Stack、Tasks、Verification
- タスク粒度: 2-5分、原則1ファイル、1つの論理的変更
- 各タスクに推奨: 対象ファイルのフルパス、変更する関数名、実行可能なコード、検証コマンドと期待出力
