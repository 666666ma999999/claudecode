# 実行ガード

## 1. ブロッカープロトコル

タスク実行中に以下が発生した場合、**即座に停止してユーザーに確認**:

| ブロッカー | 対応 |
|-----------|------|
| プランの指示が不明確 | 停止 → 具体的な質問を提示 → 回答を待つ |
| テスト/検証が失敗 | 停止 → 4段階根本原因分析に従い調査 → 報告 |
| プラン外の変更が必要と判明 | 停止 → 追加変更の範囲を提示 → 承認を待つ |
| 想定外の依存関係を発見 | 停止 → 影響範囲を報告 → 判断を待つ |

**禁止**: ブロッカーを推測で回避、「おそらくこうだろう」で判断して修正

## 2. バッチ実行方式

タスクを3つずつバッチ化し、バッチごとに検証ポイントを設ける:
- バッチ実行 → 検証 → ユーザーへ中間報告 → 承認後に次バッチ
- 単純な変更: 最大5タスク/バッチまで拡大可
- リスクの高い変更: 1タスク/バッチに縮小

## 3. SubAgent委託テンプレート

SubAgentにタスク委託時、以下を全て提供すること:
```
1. Goal: このタスクで達成すべきこと
2. Context: 関連ファイルパス・関数名・データフロー
3. Spec: 入出力の仕様（型・値の範囲・エッジケース）
4. Constraints: 既存コードとの整合性要件
5. Verification: テストコマンドと期待結果
```
**必要な情報が全て委託内容に含まれている**状態が理想。

## 4. デバッグ鉄則

**根本原因を特定するまで修正に着手しない。** 3回修正失敗で停止。詳細は debugging-guide スキル参照。

## 5. リファクタリング戦略

参考コード方式で横展開。詳細は refactoring-guide スキル参照。

## 6. プラン作成基準

Plan SubAgentが作成するプランには以下を含める:
- Goal（1-2文）、Architecture（モジュール構成図）、Tech Stack、Tasks、Verification
- タスク粒度: 2-5分、原則1ファイル、1つの論理的変更
- 各タスクに推奨: 対象ファイルのフルパス、変更する関数名、実行可能なコード、検証コマンドと期待出力
