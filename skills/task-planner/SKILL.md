---
name: task-planner
description: ざっくりした要望を具体的なファイル単位タスクに分解し、実装計画を策定するスキル
metadata:
  author: masaaki-nagasawa
  version: 1.0.0
---

# タスク細分化・実装計画策定スキル

## トリガー条件

以下のようなざっくりした要望を受けた時に自動発動:
- 「〜機能が欲しい」「〜を追加して」「〜できるようにして」
- 「〜を改善して」「〜をリファクタリングして」
- 複数ファイルにまたがる変更が予想される要望全般

## 入力

- ユーザーからの自然言語による要望（日本語 or 英語）

## 出力

- `.claude/workspace/task.md` にマークダウン形式の実装計画を書き出す

## ワークフロー

### Phase 1: 要件整理

`AskUserQuestion`で曖昧な点を具体化する。確認すべき項目:

- **対象範囲**: どの画面・機能に影響するか
- **ユーザー操作**: どういう操作で何が起きるべきか
- **エッジケース**: エラー時・データなし時の挙動
- **優先度**: 必須機能 vs あれば嬉しい機能

### Phase 2: 既存コード調査

`Task(subagent_type=Explore)`で以下を調査する。プロンプト例:

```
「[要望の要約]に関連する既存実装を調査してください。
調査対象:
1. 類似機能の既存実装（関数名・ファイルパスを列挙）
2. 拡張可能なポイント（既存関数にパラメータ追加で対応できるか）
3. 影響を受ける他のファイル・関数の一覧
4. 再利用可能なユーティリティ関数・UIパターン
成功基準: 変更が必要なファイル一覧と、各ファイルの既存実装パターンが特定できること」
```

### Phase 3: タスク分解

Phase 2の調査結果をもとに、ファイル単位の修正タスクに分解する。

各タスクの記載ルール:
- **タスク名**: 動詞で始める（例: 「追加」「修正」「拡張」）
- **対象ファイル**: フルパスで記載（例: `backend/routers/manuscripts.py`）
- **変更内容**: 追加・修正する関数名またはセクション名を明記
- **依存タスク**: このタスクの前に完了すべきタスク番号（なければ「なし」）
- **テスト**: テストが必要な場合、同じタスク内に含める

分解の粒度:
- 1タスク = 1ファイルの1つの論理的変更
- 複数の独立した変更が同一ファイルにある場合は分割する

### Phase 4: 依存関係整理

実行順序を以下の優先度で決定:

1. **データモデル・型定義** (models.py等)
2. **バックエンドAPI** (routers/, services/)
3. **フロントエンドUI** (HTML, JS, CSS)
4. **設定・定数** (config等)
5. **テスト・検証**

### Phase 4.5: タスク粒度確認

`plan-execution-guide.md`の粒度ルールに照らし、各タスクが以下を満たすか確認する:

| 基準 | 値 |
|------|-----|
| 目安作業時間 | 2-5分 |
| ファイル数 | 原則1ファイル |
| 変更箇所 | 1つの論理的変更 |

5分を超えるタスクはさらに分割する。完全性要件として、各タスクに**対象ファイルのフルパス**、**変更する関数名**、**検証コマンドと期待結果**を含めることを推奨。

### Phase 5: task.mdに出力

`.claude/workspace/task.md`に以下の形式で書き出す:

```markdown
# タスク: [要望の要約]

## メタ情報
- ステータス: 計画中
- 作成日時: YYYY-MM-DD HH:MM

## 成功基準
- [ ] [ユーザーが確認可能な完了条件を具体的に記載]
- [ ] [例: 「○○ボタンを押すと△△が表示される」]

## 実装計画

### Phase 1: [フェーズ名（例: データモデル追加）]
- [ ] T1: [動詞+対象] | `ファイルパス` | 依存: なし | [追加する関数名・変更箇所を明記]
- [ ] T2: [動詞+対象] | `ファイルパス` | 依存: T1 | [追加する関数名・変更箇所を明記]

### Phase 2: [フェーズ名（例: API実装）]
- [ ] T3: [動詞+対象] | `ファイルパス` | 依存: T1 | [追加する関数名・変更箇所を明記]

## 中断時の状態
- 次のアクション: Phase 1のT1から開始
- 未解決問題: なし
```

## プラン実行ルール

task.mdが作成されたら、実行時は`plan-execution-guide.md`のルールに従うこと:

- **バッチ実行**: 3タスクずつ実行し、バッチごとに検証・中間報告を行う
- **ブロッカープロトコル**: テスト失敗・プラン不明確・想定外の依存発見時は即停止してユーザーに確認
- **SubAgent委託時**: 完全仕様（Goal/Context/Spec/Constraints/Verification）を提供すること

## 注意事項

- 新規ファイル作成は最終手段。既存ファイル拡張を優先（development.md準拠）
- 計画策定後、`AskUserQuestion`でユーザーに方向性を確認してから実装開始

## プラン品質基準

### プラン必須セクション

Plan SubAgent（CLAUDE.md Step 3）が作成するプランには、以下のセクションを含めること:

```
## Goal
[1-2文で達成目標を明記]

## Architecture
[変更対象のモジュール構成図・データフロー]

## Tech Stack
[使用する言語・フレームワーク・ライブラリ]

## Tasks
[タスク一覧（下記の粒度ルールに従う）]

## Verification
[全体の検証方法]
```

### タスク粒度ルール

各タスクは以下の基準で分解する:

| 基準 | 値 |
|------|-----|
| 目安作業時間 | 2-5分 |
| ファイル数 | 原則1ファイル |
| 変更箇所 | 1つの論理的変更 |

### タスク記述の完全性要件（推奨）

各タスクには以下を含めることを推奨:
- **対象ファイルのフルパス**
- **変更する関数名・セクション名**
- **実行可能なコード**（擬似コードではなく実際のコード）
- **検証コマンド**と**期待される出力**

```markdown
# 例: 良いタスク記述
- T3: `backend/routers/users.py` の `get_user()` にキャッシュ追加
  - 変更: functools.lru_cacheデコレータを追加
  - コード: `@lru_cache(maxsize=128)`
  - 検証: `pytest tests/test_users.py::test_get_user_cached -v`
  - 期待: PASSED（2回目の呼び出しがDB不要）

# 例: 避けるべきタスク記述
- T3: ユーザー取得にキャッシュを追加する
```
