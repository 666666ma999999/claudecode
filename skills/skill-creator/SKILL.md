---
name: skill-creator
description: |
  会話のパターンやワークフローを再利用可能なスキルとして保存するスキル。
  新規スキルの作成手順とベストプラクティスを提供。
  キーワード: スキル作成, ワークフロー保存, パターン化
metadata:
  author: masaaki-nagasawa
  version: 1.0.0
---

# Skill Creator

このスキルは、会話のパターンやワークフローを再利用可能なスキルとして保存するためのものです。

## トリガー

以下のフレーズで発動します：
- 「skill-creatorを使って」
- 「スキルを作成して」
- 「これまでの会話をスキル化して」

## 新規スキル作成フロー

ユーザーが「skill-creatorを使って、○○のスキルを作成して」と言った場合：

1. **AskUserQuestion ツールを使って以下を確認する**：
   - スキル名（ファイル名に使用）
   - スキルの目的・概要
   - トリガーとなるフレーズやキーワード
   - スキルのスコープ（グローバル `~/.claude/skills/` or プロジェクト `.claude/skills/`）

2. **スキルファイルを生成**：
   - Markdown 形式で作成
   - 以下のセクションを含める：
     - `# スキル名` - タイトル
     - `## トリガー` - 発動条件
     - `## 手順` - 実行する手順
     - `## 出力形式` - 期待される出力（任意）
     - `## 例` - 使用例（任意）

3. **ファイルを保存**：
   - 指定されたスコープのディレクトリに保存
   - ファイル名: `{スキル名}.md`

## 会話からのスキル化フロー

ユーザーが「これまでの会話の流れをスキル化して」と言った場合：

1. **会話を分析**：
   - 成功したワークフローのパターンを特定
   - 使用したツール・手順を抽出
   - ユーザーの判断ポイントを特定

2. **AskUserQuestion ツールで確認**：
   - スキル名
   - 保存スコープ
   - 追加したい情報や調整

3. **スキルファイルを生成・保存**

## スキルファイルのテンプレート

```markdown
# {スキル名}

{スキルの概要・目的}

## トリガー

以下のフレーズで発動します：
- 「{トリガー1}」
- 「{トリガー2}」

## 手順

1. {手順1}
2. {手順2}
3. {手順3}

## ユーザーへの確認事項

以下の判断が必要な場合は AskUserQuestion ツールを使用：
- {確認事項1}
- {確認事項2}

## 出力形式

{期待される出力の形式}

## 例

### 入力例
{入力例}

### 出力例
{出力例}
```

## 保存先

| スコープ | パス | 用途 |
|----------|------|------|
| グローバル | `~/.claude/skills/` | 全プロジェクトで使用 |
| プロジェクト | `.claude/skills/` | 特定プロジェクトのみ |

## ディレクトリ構造パターン

### シンプルなスキル（単一ファイル）
```
~/.claude/skills/
└── my-skill.md
```

### 複雑なスキル（ディレクトリ + references）
```
~/.claude/skills/my-skill/
├── SKILL.md              # メイン定義（必須）
└── references/           # 参照ドキュメント
    ├── pattern-1.md      # 詳細パターン集1
    ├── pattern-2.md      # 詳細パターン集2
    └── examples.md       # 使用例集
```

### ディレクトリ構造を使う基準
- **単一ファイル**: 手順が10ステップ以下、コード例が少ない
- **ディレクトリ**: 以下のいずれかに該当
  - 複数の独立したパターンがある
  - コード例が多い（3000行超）
  - カテゴリ別に整理したい
  - 将来的に拡張予定がある

### SKILL.md（ディレクトリ版）のテンプレート

```markdown
---
name: my-skill
description: |
  スキルの説明。発動条件やキーワードを含める。
  キーワード: キーワード1, キーワード2, キーワード3
---

# スキル名

概要説明

## 発動条件
- 「〜」と言われた場合
- 「〜」のキーワードが含まれる場合

## 基本フロー
1. ステップ1
2. ステップ2
3. ステップ3

## 参照ファイル
- `references/pattern-1.md` - パターン1の詳細
- `references/pattern-2.md` - パターン2の詳細

## チェックリスト
- [ ] 確認事項1
- [ ] 確認事項2
```

### 実例: fe-be-integration スキル

```
~/.claude/skills/fe-be-integration/
├── SKILL.md                    # 12.5KB - 7フェーズの概要、設計原則
└── references/
    ├── api-patterns.md         # 7.4KB - APIエンドポイント設計
    ├── fallback-patterns.md    # 9.4KB - フォールバック実装
    ├── progress-patterns.md    # 10.1KB - 進捗追跡パターン
    └── validation-patterns.md  # 14KB - バリデーション設計
```

この構造により:
- SKILL.mdは概要のみで軽量
- 詳細パターンは参照ファイルに分離
- 必要な部分だけ参照可能
- Codex MCPで追加の重複を発見→新しいPhaseを追加可能

## スキルのカテゴリ別テンプレート

### 1. テスト系スキル
```markdown
## 前提条件
- 必要なツール・環境

## テスト対象の特定
- 対象を自動検出する方法

## テスト実行
- 各項目のテスト手順

## 結果報告
- 表形式での成功/失敗一覧
```

### 2. 自動化系スキル
```markdown
## 入力パラメータ
- ユーザーから受け取る情報

## 処理フロー
- 順次実行する処理

## エラーハンドリング
- 失敗時の対応

## 完了条件
- 成功の判定基準
```

### 3. 調査・分析系スキル
```markdown
## 調査範囲
- 対象ファイル・ディレクトリ

## 分析方法
- 使用するツール・コマンド

## 出力形式
- 分析結果のフォーマット
```

## Codex MCPを使ったコード分析からのスキル作成

既存コードベースから再利用可能なパターンを抽出してスキル化する場合、
Codex MCPを使った分析が効果的。

### 分析プロンプト例

```
Codex MCPを使って、現環境のFEとBEの関数で同じ処理をしている関数を
BE側で統合して保守性を高め、コード量を減らせるアーキテクト案を作成して下さい。
```

### Codexが返す分析結果の活用

1. **重複箇所の特定**
   - `frontend/utils.js:264-311` の `formatTimestamp` ↔ `backend/utils/datetime.py:160-182`
   - ファイルパスと行番号で具体的に示される

2. **実装案の提案**
   - API設計（エンドポイント、リクエスト/レスポンス形式）
   - フェーズ分けの提案（Phase 1: 定数統合 → Phase 2: ロジック統合 → ...）

3. **スキル化のポイント**
   - Codexの分析結果から繰り返し使えるパターンを抽出
   - 具体的なコード例をスキルに含める
   - フェーズ分けのアプローチを文書化

### 実例: fe-be-integration スキルの作成過程

1. Codex MCPでFE/BE重複コードを分析
2. 8フェーズの統合計画を策定（7フェーズ実装 + 1フェーズクリーンアップ）
3. 各フェーズのパターンをreferences/に文書化
4. SKILL.mdに概要とチェックリストを記載

### 実装→クリーンアップのワークフロー

大きな変更を実装した後は、必ずクリーンアップフェーズを設ける：

```
[実装フェーズ]
1. 新機能/API追加
2. 動作確認
3. スキル文書化

[クリーンアップフェーズ]
4. Codex MCPで冗長コード分析
   → 「実装後に不要になったコードを特定してください」
5. 3段階で整理
   - Phase A: ハードコード削除（空オブジェクトに変更）
   - Phase B: 完全削除（API版に統合済みの関数）
   - Phase C: 簡略化（フォールバック最小化）
6. 削減効果の記録
```

**クリーンアップ分析プロンプト例**:
```
Codex MCPを使って、今回の実装で不要になったコードを特定してください：
1. BE APIが存在するローカル関数
2. ハードコードされた定数（BE設定で配信済み）
3. 重複した正規表現パターン
4. 未使用のフォールバック関数
```

このワークフローにより、機能追加と同時にコード品質も向上する。

## 会話からスキル抽出のコツ

### 抽出すべき要素
1. **繰り返しパターン**: 同じツールを複数回使用した箇所
2. **成功した手順**: エラーなく完了したワークフロー
3. **判断ポイント**: ユーザーに確認した箇所
4. **出力形式**: 最終的に提示した結果の形式

### 良いスキルの特徴
- **具体的なコード例**: 実行するコマンドやスクリプトを含む
- **エラー対応**: よくある失敗とその対処法
- **柔軟性**: パラメータで調整可能な部分を明示

## 成功例：実際に作成されたスキル

### full-ui-test
- **目的**: 画面上の全ボタンをクリックしてテスト
- **抽出元**: Chrome DevToolsでのUIテスト会話
- **特徴**:
  - スナップショットからボタン抽出のPythonコード
  - テスト結果の表形式出力
  - ダイアログ処理の手順

### lottery-automation
- **目的**: 抽選サイトへの自動応募
- **特徴**:
  - ブラウザ操作の自動化手順
  - 履歴管理機能

### fe-be-integration（Codex MCP分析から作成）
- **目的**: FE/BE間の重複コードを統合して保守性向上
- **抽出元**: Codex MCPによるコードベース分析
- **特徴**:
  - 8フェーズの段階的アプローチ（7実装 + 1クリーンアップ）
  - 5つのreferencesファイルで詳細パターンを分離
  - 分析→計画→実装→クリーンアップ→検証のワークフロー
  - FastAPIルート順序などの実装注意点
  - クリーンアップで約40行のFEコード削減

## スキル改善のフィードバックループ

スキル使用後に以下を確認し、改善を提案：
1. 手順の過不足はないか
2. エラーが発生した箇所
3. ユーザーが追加で質問した内容
4. 出力形式の改善点
